// Code generated by goa v3.21.5, DO NOT EDIT.
//
// committee HTTP server types
//
// Command:
// $ goa gen
// github.com/linuxfoundation/lfx-v2-committee-service/cmd/lfx-v2-committee-service/design

package server

import (
	"unicode/utf8"

	committee "github.com/linuxfoundation/lfx-v2-committee-service/gen/committee"
	goa "goa.design/goa/v3/pkg"
)

// CreateCommitteeRequestBody is the type of the "committee" service
// "create-committee" endpoint HTTP request body.
type CreateCommitteeRequestBody struct {
	// The name of the committee
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// The category of the committee
	Category *string `form:"category,omitempty" json:"category,omitempty" xml:"category,omitempty"`
	// The description of the committee
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// The website URL of the committee
	Website *string `form:"website,omitempty" json:"website,omitempty" xml:"website,omitempty"`
	// Whether voting is enabled for this committee
	EnableVoting *bool `form:"enable_voting,omitempty" json:"enable_voting,omitempty" xml:"enable_voting,omitempty"`
	// Whether business email is required for committee members
	BusinessEmailRequired *bool `form:"business_email_required,omitempty" json:"business_email_required,omitempty" xml:"business_email_required,omitempty"`
	// Whether SSO group integration is enabled
	SsoGroupEnabled *bool `form:"sso_group_enabled,omitempty" json:"sso_group_enabled,omitempty" xml:"sso_group_enabled,omitempty"`
	// The name of the SSO group
	SsoGroupName *string `form:"sso_group_name,omitempty" json:"sso_group_name,omitempty" xml:"sso_group_name,omitempty"`
	// Whether audit logging is enabled for this committee
	IsAuditEnabled *bool `form:"is_audit_enabled,omitempty" json:"is_audit_enabled,omitempty" xml:"is_audit_enabled,omitempty"`
	// Whether the committee is publicly visible
	Public *bool `form:"public,omitempty" json:"public,omitempty" xml:"public,omitempty"`
	// The public display name of the committee
	PublicName *string `form:"public_name,omitempty" json:"public_name,omitempty" xml:"public_name,omitempty"`
	// The ID of the parent committee, should be empty if there is none
	ParentCommitteeID *string `form:"parent_committee_id,omitempty" json:"parent_committee_id,omitempty" xml:"parent_committee_id,omitempty"`
	// The current status of the committee
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// Manager user IDs who can edit/modify this committee
	Writers []string `form:"writers,omitempty" json:"writers,omitempty" xml:"writers,omitempty"`
}

// UpdateCommitteeRequestBody is the type of the "committee" service
// "update-committee" endpoint HTTP request body.
type UpdateCommitteeRequestBody struct {
	// The project identifier this committee belongs to
	ProjectID *string `form:"project_id,omitempty" json:"project_id,omitempty" xml:"project_id,omitempty"`
	// The name of the committee
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// The category of the committee
	Category *string `form:"category,omitempty" json:"category,omitempty" xml:"category,omitempty"`
	// The description of the committee
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// The website URL of the committee
	Website *string `form:"website,omitempty" json:"website,omitempty" xml:"website,omitempty"`
	// Whether voting is enabled for this committee
	EnableVoting *bool `form:"enable_voting,omitempty" json:"enable_voting,omitempty" xml:"enable_voting,omitempty"`
	// Whether business email is required for committee members
	BusinessEmailRequired *bool `form:"business_email_required,omitempty" json:"business_email_required,omitempty" xml:"business_email_required,omitempty"`
	// Whether SSO group integration is enabled
	SsoGroupEnabled *bool `form:"sso_group_enabled,omitempty" json:"sso_group_enabled,omitempty" xml:"sso_group_enabled,omitempty"`
	// The name of the SSO group
	SsoGroupName *string `form:"sso_group_name,omitempty" json:"sso_group_name,omitempty" xml:"sso_group_name,omitempty"`
	// Whether audit logging is enabled for this committee
	IsAuditEnabled *bool `form:"is_audit_enabled,omitempty" json:"is_audit_enabled,omitempty" xml:"is_audit_enabled,omitempty"`
	// Whether the committee is publicly visible
	Public *bool `form:"public,omitempty" json:"public,omitempty" xml:"public,omitempty"`
	// The public display name of the committee
	PublicName *string `form:"public_name,omitempty" json:"public_name,omitempty" xml:"public_name,omitempty"`
	// The ID of the parent committee, should be empty if there is none
	ParentCommitteeID *string `form:"parent_committee_id,omitempty" json:"parent_committee_id,omitempty" xml:"parent_committee_id,omitempty"`
	// The current status of the committee
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// Manager user IDs who can edit/modify this committee
	Writers []string `form:"writers,omitempty" json:"writers,omitempty" xml:"writers,omitempty"`
}

// CreateCommitteeResponseBody is the type of the "committee" service
// "create-committee" endpoint HTTP response body.
type CreateCommitteeResponseBody struct {
	// The unique identifier of the committee
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The project identifier this committee belongs to
	ProjectID *string `form:"project_id,omitempty" json:"project_id,omitempty" xml:"project_id,omitempty"`
	// The name of the committee
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// The category of the committee
	Category *string `form:"category,omitempty" json:"category,omitempty" xml:"category,omitempty"`
	// The description of the committee
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// The website URL of the committee
	Website *string `form:"website,omitempty" json:"website,omitempty" xml:"website,omitempty"`
	// Whether voting is enabled for this committee
	EnableVoting bool `form:"enable_voting" json:"enable_voting" xml:"enable_voting"`
	// Whether business email is required for committee members
	BusinessEmailRequired bool `form:"business_email_required" json:"business_email_required" xml:"business_email_required"`
	// Whether SSO group integration is enabled
	SsoGroupEnabled bool `form:"sso_group_enabled" json:"sso_group_enabled" xml:"sso_group_enabled"`
	// The name of the SSO group
	SsoGroupName *string `form:"sso_group_name,omitempty" json:"sso_group_name,omitempty" xml:"sso_group_name,omitempty"`
	// Whether audit logging is enabled for this committee
	IsAuditEnabled bool `form:"is_audit_enabled" json:"is_audit_enabled" xml:"is_audit_enabled"`
	// Whether the committee is publicly visible
	Public bool `form:"public" json:"public" xml:"public"`
	// The public display name of the committee
	PublicName *string `form:"public_name,omitempty" json:"public_name,omitempty" xml:"public_name,omitempty"`
	// The ID of the parent committee, should be empty if there is none
	ParentCommitteeID *string `form:"parent_committee_id,omitempty" json:"parent_committee_id,omitempty" xml:"parent_committee_id,omitempty"`
	// The current status of the committee
	Status string `form:"status" json:"status" xml:"status"`
	// Manager user IDs who can edit/modify this committee
	Writers []string `form:"writers,omitempty" json:"writers,omitempty" xml:"writers,omitempty"`
}

// GetCommitteeResponseBody is the type of the "committee" service
// "get-committee" endpoint HTTP response body.
type GetCommitteeResponseBody CommitteeResponseBody

// UpdateCommitteeResponseBody is the type of the "committee" service
// "update-committee" endpoint HTTP response body.
type UpdateCommitteeResponseBody struct {
	// The unique identifier of the committee
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The project identifier this committee belongs to
	ProjectID *string `form:"project_id,omitempty" json:"project_id,omitempty" xml:"project_id,omitempty"`
	// The name of the committee
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// The category of the committee
	Category *string `form:"category,omitempty" json:"category,omitempty" xml:"category,omitempty"`
	// The description of the committee
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// The website URL of the committee
	Website *string `form:"website,omitempty" json:"website,omitempty" xml:"website,omitempty"`
	// Whether voting is enabled for this committee
	EnableVoting bool `form:"enable_voting" json:"enable_voting" xml:"enable_voting"`
	// Whether business email is required for committee members
	BusinessEmailRequired bool `form:"business_email_required" json:"business_email_required" xml:"business_email_required"`
	// Whether SSO group integration is enabled
	SsoGroupEnabled bool `form:"sso_group_enabled" json:"sso_group_enabled" xml:"sso_group_enabled"`
	// The name of the SSO group
	SsoGroupName *string `form:"sso_group_name,omitempty" json:"sso_group_name,omitempty" xml:"sso_group_name,omitempty"`
	// Whether audit logging is enabled for this committee
	IsAuditEnabled bool `form:"is_audit_enabled" json:"is_audit_enabled" xml:"is_audit_enabled"`
	// Whether the committee is publicly visible
	Public bool `form:"public" json:"public" xml:"public"`
	// The public display name of the committee
	PublicName *string `form:"public_name,omitempty" json:"public_name,omitempty" xml:"public_name,omitempty"`
	// The ID of the parent committee, should be empty if there is none
	ParentCommitteeID *string `form:"parent_committee_id,omitempty" json:"parent_committee_id,omitempty" xml:"parent_committee_id,omitempty"`
	// The current status of the committee
	Status string `form:"status" json:"status" xml:"status"`
	// Manager user IDs who can edit/modify this committee
	Writers []string `form:"writers,omitempty" json:"writers,omitempty" xml:"writers,omitempty"`
}

// CreateCommitteeBadRequestResponseBody is the type of the "committee" service
// "create-committee" endpoint HTTP response body for the "BadRequest" error.
type CreateCommitteeBadRequestResponseBody struct {
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// CreateCommitteeConflictResponseBody is the type of the "committee" service
// "create-committee" endpoint HTTP response body for the "Conflict" error.
type CreateCommitteeConflictResponseBody struct {
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// CreateCommitteeInternalServerErrorResponseBody is the type of the
// "committee" service "create-committee" endpoint HTTP response body for the
// "InternalServerError" error.
type CreateCommitteeInternalServerErrorResponseBody struct {
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// CreateCommitteeServiceUnavailableResponseBody is the type of the "committee"
// service "create-committee" endpoint HTTP response body for the
// "ServiceUnavailable" error.
type CreateCommitteeServiceUnavailableResponseBody struct {
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// GetCommitteeInternalServerErrorResponseBody is the type of the "committee"
// service "get-committee" endpoint HTTP response body for the
// "InternalServerError" error.
type GetCommitteeInternalServerErrorResponseBody struct {
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// GetCommitteeNotFoundResponseBody is the type of the "committee" service
// "get-committee" endpoint HTTP response body for the "NotFound" error.
type GetCommitteeNotFoundResponseBody struct {
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// GetCommitteeServiceUnavailableResponseBody is the type of the "committee"
// service "get-committee" endpoint HTTP response body for the
// "ServiceUnavailable" error.
type GetCommitteeServiceUnavailableResponseBody struct {
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// UpdateCommitteeBadRequestResponseBody is the type of the "committee" service
// "update-committee" endpoint HTTP response body for the "BadRequest" error.
type UpdateCommitteeBadRequestResponseBody struct {
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// UpdateCommitteeInternalServerErrorResponseBody is the type of the
// "committee" service "update-committee" endpoint HTTP response body for the
// "InternalServerError" error.
type UpdateCommitteeInternalServerErrorResponseBody struct {
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// UpdateCommitteeNotFoundResponseBody is the type of the "committee" service
// "update-committee" endpoint HTTP response body for the "NotFound" error.
type UpdateCommitteeNotFoundResponseBody struct {
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// UpdateCommitteeServiceUnavailableResponseBody is the type of the "committee"
// service "update-committee" endpoint HTTP response body for the
// "ServiceUnavailable" error.
type UpdateCommitteeServiceUnavailableResponseBody struct {
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// DeleteCommitteeBadRequestResponseBody is the type of the "committee" service
// "delete-committee" endpoint HTTP response body for the "BadRequest" error.
type DeleteCommitteeBadRequestResponseBody struct {
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// DeleteCommitteeInternalServerErrorResponseBody is the type of the
// "committee" service "delete-committee" endpoint HTTP response body for the
// "InternalServerError" error.
type DeleteCommitteeInternalServerErrorResponseBody struct {
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// DeleteCommitteeNotFoundResponseBody is the type of the "committee" service
// "delete-committee" endpoint HTTP response body for the "NotFound" error.
type DeleteCommitteeNotFoundResponseBody struct {
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// DeleteCommitteeServiceUnavailableResponseBody is the type of the "committee"
// service "delete-committee" endpoint HTTP response body for the
// "ServiceUnavailable" error.
type DeleteCommitteeServiceUnavailableResponseBody struct {
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// ReadyzServiceUnavailableResponseBody is the type of the "committee" service
// "readyz" endpoint HTTP response body for the "ServiceUnavailable" error.
type ReadyzServiceUnavailableResponseBody struct {
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// CommitteeResponseBody is used to define fields on response body types.
type CommitteeResponseBody struct {
	// The unique identifier of the committee
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The project identifier this committee belongs to
	ProjectID *string `form:"project_id,omitempty" json:"project_id,omitempty" xml:"project_id,omitempty"`
	// The name of the committee
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// The category of the committee
	Category *string `form:"category,omitempty" json:"category,omitempty" xml:"category,omitempty"`
	// The description of the committee
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// The website URL of the committee
	Website *string `form:"website,omitempty" json:"website,omitempty" xml:"website,omitempty"`
	// Whether voting is enabled for this committee
	EnableVoting bool `form:"enable_voting" json:"enable_voting" xml:"enable_voting"`
	// Whether business email is required for committee members
	BusinessEmailRequired bool `form:"business_email_required" json:"business_email_required" xml:"business_email_required"`
	// Whether SSO group integration is enabled
	SsoGroupEnabled bool `form:"sso_group_enabled" json:"sso_group_enabled" xml:"sso_group_enabled"`
	// The name of the SSO group
	SsoGroupName *string `form:"sso_group_name,omitempty" json:"sso_group_name,omitempty" xml:"sso_group_name,omitempty"`
	// Whether audit logging is enabled for this committee
	IsAuditEnabled bool `form:"is_audit_enabled" json:"is_audit_enabled" xml:"is_audit_enabled"`
	// Whether the committee is publicly visible
	Public bool `form:"public" json:"public" xml:"public"`
	// The public display name of the committee
	PublicName *string `form:"public_name,omitempty" json:"public_name,omitempty" xml:"public_name,omitempty"`
	// The ID of the parent committee, should be empty if there is none
	ParentCommitteeID *string `form:"parent_committee_id,omitempty" json:"parent_committee_id,omitempty" xml:"parent_committee_id,omitempty"`
	// The current status of the committee
	Status string `form:"status" json:"status" xml:"status"`
	// Manager user IDs who can edit/modify this committee
	Writers []string `form:"writers,omitempty" json:"writers,omitempty" xml:"writers,omitempty"`
}

// NewCreateCommitteeResponseBody builds the HTTP response body from the result
// of the "create-committee" endpoint of the "committee" service.
func NewCreateCommitteeResponseBody(res *committee.Committee) *CreateCommitteeResponseBody {
	body := &CreateCommitteeResponseBody{
		ID:                    res.ID,
		ProjectID:             res.ProjectID,
		Name:                  res.Name,
		Category:              res.Category,
		Description:           res.Description,
		Website:               res.Website,
		EnableVoting:          res.EnableVoting,
		BusinessEmailRequired: res.BusinessEmailRequired,
		SsoGroupEnabled:       res.SsoGroupEnabled,
		SsoGroupName:          res.SsoGroupName,
		IsAuditEnabled:        res.IsAuditEnabled,
		Public:                res.Public,
		PublicName:            res.PublicName,
		ParentCommitteeID:     res.ParentCommitteeID,
		Status:                res.Status,
	}
	{
		var zero bool
		if body.EnableVoting == zero {
			body.EnableVoting = false
		}
	}
	{
		var zero bool
		if body.BusinessEmailRequired == zero {
			body.BusinessEmailRequired = false
		}
	}
	{
		var zero bool
		if body.SsoGroupEnabled == zero {
			body.SsoGroupEnabled = false
		}
	}
	{
		var zero bool
		if body.IsAuditEnabled == zero {
			body.IsAuditEnabled = false
		}
	}
	{
		var zero bool
		if body.Public == zero {
			body.Public = false
		}
	}
	{
		var zero string
		if body.Status == zero {
			body.Status = "active"
		}
	}
	if res.Writers != nil {
		body.Writers = make([]string, len(res.Writers))
		for i, val := range res.Writers {
			body.Writers[i] = val
		}
	}
	return body
}

// NewGetCommitteeResponseBody builds the HTTP response body from the result of
// the "get-committee" endpoint of the "committee" service.
func NewGetCommitteeResponseBody(res *committee.GetCommitteeResult) *GetCommitteeResponseBody {
	body := &GetCommitteeResponseBody{
		ID:                    res.Committee.ID,
		ProjectID:             res.Committee.ProjectID,
		Name:                  res.Committee.Name,
		Category:              res.Committee.Category,
		Description:           res.Committee.Description,
		Website:               res.Committee.Website,
		EnableVoting:          res.Committee.EnableVoting,
		BusinessEmailRequired: res.Committee.BusinessEmailRequired,
		SsoGroupEnabled:       res.Committee.SsoGroupEnabled,
		SsoGroupName:          res.Committee.SsoGroupName,
		IsAuditEnabled:        res.Committee.IsAuditEnabled,
		Public:                res.Committee.Public,
		PublicName:            res.Committee.PublicName,
		ParentCommitteeID:     res.Committee.ParentCommitteeID,
		Status:                res.Committee.Status,
	}
	{
		var zero bool
		if body.EnableVoting == zero {
			body.EnableVoting = false
		}
	}
	{
		var zero bool
		if body.BusinessEmailRequired == zero {
			body.BusinessEmailRequired = false
		}
	}
	{
		var zero bool
		if body.SsoGroupEnabled == zero {
			body.SsoGroupEnabled = false
		}
	}
	{
		var zero bool
		if body.IsAuditEnabled == zero {
			body.IsAuditEnabled = false
		}
	}
	{
		var zero bool
		if body.Public == zero {
			body.Public = false
		}
	}
	{
		var zero string
		if body.Status == zero {
			body.Status = "active"
		}
	}
	if res.Committee.Writers != nil {
		body.Writers = make([]string, len(res.Committee.Writers))
		for i, val := range res.Committee.Writers {
			body.Writers[i] = val
		}
	}
	return body
}

// NewUpdateCommitteeResponseBody builds the HTTP response body from the result
// of the "update-committee" endpoint of the "committee" service.
func NewUpdateCommitteeResponseBody(res *committee.Committee) *UpdateCommitteeResponseBody {
	body := &UpdateCommitteeResponseBody{
		ID:                    res.ID,
		ProjectID:             res.ProjectID,
		Name:                  res.Name,
		Category:              res.Category,
		Description:           res.Description,
		Website:               res.Website,
		EnableVoting:          res.EnableVoting,
		BusinessEmailRequired: res.BusinessEmailRequired,
		SsoGroupEnabled:       res.SsoGroupEnabled,
		SsoGroupName:          res.SsoGroupName,
		IsAuditEnabled:        res.IsAuditEnabled,
		Public:                res.Public,
		PublicName:            res.PublicName,
		ParentCommitteeID:     res.ParentCommitteeID,
		Status:                res.Status,
	}
	{
		var zero bool
		if body.EnableVoting == zero {
			body.EnableVoting = false
		}
	}
	{
		var zero bool
		if body.BusinessEmailRequired == zero {
			body.BusinessEmailRequired = false
		}
	}
	{
		var zero bool
		if body.SsoGroupEnabled == zero {
			body.SsoGroupEnabled = false
		}
	}
	{
		var zero bool
		if body.IsAuditEnabled == zero {
			body.IsAuditEnabled = false
		}
	}
	{
		var zero bool
		if body.Public == zero {
			body.Public = false
		}
	}
	{
		var zero string
		if body.Status == zero {
			body.Status = "active"
		}
	}
	if res.Writers != nil {
		body.Writers = make([]string, len(res.Writers))
		for i, val := range res.Writers {
			body.Writers[i] = val
		}
	}
	return body
}

// NewCreateCommitteeBadRequestResponseBody builds the HTTP response body from
// the result of the "create-committee" endpoint of the "committee" service.
func NewCreateCommitteeBadRequestResponseBody(res *committee.BadRequestError) *CreateCommitteeBadRequestResponseBody {
	body := &CreateCommitteeBadRequestResponseBody{
		Message: res.Message,
	}
	return body
}

// NewCreateCommitteeConflictResponseBody builds the HTTP response body from
// the result of the "create-committee" endpoint of the "committee" service.
func NewCreateCommitteeConflictResponseBody(res *committee.ConflictError) *CreateCommitteeConflictResponseBody {
	body := &CreateCommitteeConflictResponseBody{
		Message: res.Message,
	}
	return body
}

// NewCreateCommitteeInternalServerErrorResponseBody builds the HTTP response
// body from the result of the "create-committee" endpoint of the "committee"
// service.
func NewCreateCommitteeInternalServerErrorResponseBody(res *committee.InternalServerError) *CreateCommitteeInternalServerErrorResponseBody {
	body := &CreateCommitteeInternalServerErrorResponseBody{
		Message: res.Message,
	}
	return body
}

// NewCreateCommitteeServiceUnavailableResponseBody builds the HTTP response
// body from the result of the "create-committee" endpoint of the "committee"
// service.
func NewCreateCommitteeServiceUnavailableResponseBody(res *committee.ServiceUnavailableError) *CreateCommitteeServiceUnavailableResponseBody {
	body := &CreateCommitteeServiceUnavailableResponseBody{
		Message: res.Message,
	}
	return body
}

// NewGetCommitteeInternalServerErrorResponseBody builds the HTTP response body
// from the result of the "get-committee" endpoint of the "committee" service.
func NewGetCommitteeInternalServerErrorResponseBody(res *committee.InternalServerError) *GetCommitteeInternalServerErrorResponseBody {
	body := &GetCommitteeInternalServerErrorResponseBody{
		Message: res.Message,
	}
	return body
}

// NewGetCommitteeNotFoundResponseBody builds the HTTP response body from the
// result of the "get-committee" endpoint of the "committee" service.
func NewGetCommitteeNotFoundResponseBody(res *committee.NotFoundError) *GetCommitteeNotFoundResponseBody {
	body := &GetCommitteeNotFoundResponseBody{
		Message: res.Message,
	}
	return body
}

// NewGetCommitteeServiceUnavailableResponseBody builds the HTTP response body
// from the result of the "get-committee" endpoint of the "committee" service.
func NewGetCommitteeServiceUnavailableResponseBody(res *committee.ServiceUnavailableError) *GetCommitteeServiceUnavailableResponseBody {
	body := &GetCommitteeServiceUnavailableResponseBody{
		Message: res.Message,
	}
	return body
}

// NewUpdateCommitteeBadRequestResponseBody builds the HTTP response body from
// the result of the "update-committee" endpoint of the "committee" service.
func NewUpdateCommitteeBadRequestResponseBody(res *committee.BadRequestError) *UpdateCommitteeBadRequestResponseBody {
	body := &UpdateCommitteeBadRequestResponseBody{
		Message: res.Message,
	}
	return body
}

// NewUpdateCommitteeInternalServerErrorResponseBody builds the HTTP response
// body from the result of the "update-committee" endpoint of the "committee"
// service.
func NewUpdateCommitteeInternalServerErrorResponseBody(res *committee.InternalServerError) *UpdateCommitteeInternalServerErrorResponseBody {
	body := &UpdateCommitteeInternalServerErrorResponseBody{
		Message: res.Message,
	}
	return body
}

// NewUpdateCommitteeNotFoundResponseBody builds the HTTP response body from
// the result of the "update-committee" endpoint of the "committee" service.
func NewUpdateCommitteeNotFoundResponseBody(res *committee.NotFoundError) *UpdateCommitteeNotFoundResponseBody {
	body := &UpdateCommitteeNotFoundResponseBody{
		Message: res.Message,
	}
	return body
}

// NewUpdateCommitteeServiceUnavailableResponseBody builds the HTTP response
// body from the result of the "update-committee" endpoint of the "committee"
// service.
func NewUpdateCommitteeServiceUnavailableResponseBody(res *committee.ServiceUnavailableError) *UpdateCommitteeServiceUnavailableResponseBody {
	body := &UpdateCommitteeServiceUnavailableResponseBody{
		Message: res.Message,
	}
	return body
}

// NewDeleteCommitteeBadRequestResponseBody builds the HTTP response body from
// the result of the "delete-committee" endpoint of the "committee" service.
func NewDeleteCommitteeBadRequestResponseBody(res *committee.BadRequestError) *DeleteCommitteeBadRequestResponseBody {
	body := &DeleteCommitteeBadRequestResponseBody{
		Message: res.Message,
	}
	return body
}

// NewDeleteCommitteeInternalServerErrorResponseBody builds the HTTP response
// body from the result of the "delete-committee" endpoint of the "committee"
// service.
func NewDeleteCommitteeInternalServerErrorResponseBody(res *committee.InternalServerError) *DeleteCommitteeInternalServerErrorResponseBody {
	body := &DeleteCommitteeInternalServerErrorResponseBody{
		Message: res.Message,
	}
	return body
}

// NewDeleteCommitteeNotFoundResponseBody builds the HTTP response body from
// the result of the "delete-committee" endpoint of the "committee" service.
func NewDeleteCommitteeNotFoundResponseBody(res *committee.NotFoundError) *DeleteCommitteeNotFoundResponseBody {
	body := &DeleteCommitteeNotFoundResponseBody{
		Message: res.Message,
	}
	return body
}

// NewDeleteCommitteeServiceUnavailableResponseBody builds the HTTP response
// body from the result of the "delete-committee" endpoint of the "committee"
// service.
func NewDeleteCommitteeServiceUnavailableResponseBody(res *committee.ServiceUnavailableError) *DeleteCommitteeServiceUnavailableResponseBody {
	body := &DeleteCommitteeServiceUnavailableResponseBody{
		Message: res.Message,
	}
	return body
}

// NewReadyzServiceUnavailableResponseBody builds the HTTP response body from
// the result of the "readyz" endpoint of the "committee" service.
func NewReadyzServiceUnavailableResponseBody(res *committee.ServiceUnavailableError) *ReadyzServiceUnavailableResponseBody {
	body := &ReadyzServiceUnavailableResponseBody{
		Message: res.Message,
	}
	return body
}

// NewCreateCommitteePayload builds a committee service create-committee
// endpoint payload.
func NewCreateCommitteePayload(body *CreateCommitteeRequestBody, version *string, bearerToken *string) *committee.CreateCommitteePayload {
	v := &committee.CreateCommitteePayload{
		Name:              *body.Name,
		Category:          *body.Category,
		Description:       body.Description,
		Website:           body.Website,
		SsoGroupName:      body.SsoGroupName,
		PublicName:        body.PublicName,
		ParentCommitteeID: body.ParentCommitteeID,
	}
	if body.EnableVoting != nil {
		v.EnableVoting = *body.EnableVoting
	}
	if body.BusinessEmailRequired != nil {
		v.BusinessEmailRequired = *body.BusinessEmailRequired
	}
	if body.SsoGroupEnabled != nil {
		v.SsoGroupEnabled = *body.SsoGroupEnabled
	}
	if body.IsAuditEnabled != nil {
		v.IsAuditEnabled = *body.IsAuditEnabled
	}
	if body.Public != nil {
		v.Public = *body.Public
	}
	if body.Status != nil {
		v.Status = *body.Status
	}
	if body.EnableVoting == nil {
		v.EnableVoting = false
	}
	if body.BusinessEmailRequired == nil {
		v.BusinessEmailRequired = false
	}
	if body.SsoGroupEnabled == nil {
		v.SsoGroupEnabled = false
	}
	if body.IsAuditEnabled == nil {
		v.IsAuditEnabled = false
	}
	if body.Public == nil {
		v.Public = false
	}
	if body.Status == nil {
		v.Status = "active"
	}
	if body.Writers != nil {
		v.Writers = make([]string, len(body.Writers))
		for i, val := range body.Writers {
			v.Writers[i] = val
		}
	}
	v.Version = version
	v.BearerToken = bearerToken

	return v
}

// NewGetCommitteePayload builds a committee service get-committee endpoint
// payload.
func NewGetCommitteePayload(id string, version *string, bearerToken *string) *committee.GetCommitteePayload {
	v := &committee.GetCommitteePayload{}
	v.ID = &id
	v.Version = version
	v.BearerToken = bearerToken

	return v
}

// NewUpdateCommitteePayload builds a committee service update-committee
// endpoint payload.
func NewUpdateCommitteePayload(body *UpdateCommitteeRequestBody, id string, version *string, bearerToken *string, etag *string) *committee.UpdateCommitteePayload {
	v := &committee.UpdateCommitteePayload{
		ProjectID:         body.ProjectID,
		Name:              *body.Name,
		Category:          *body.Category,
		Description:       body.Description,
		Website:           body.Website,
		SsoGroupName:      body.SsoGroupName,
		PublicName:        body.PublicName,
		ParentCommitteeID: body.ParentCommitteeID,
	}
	if body.EnableVoting != nil {
		v.EnableVoting = *body.EnableVoting
	}
	if body.BusinessEmailRequired != nil {
		v.BusinessEmailRequired = *body.BusinessEmailRequired
	}
	if body.SsoGroupEnabled != nil {
		v.SsoGroupEnabled = *body.SsoGroupEnabled
	}
	if body.IsAuditEnabled != nil {
		v.IsAuditEnabled = *body.IsAuditEnabled
	}
	if body.Public != nil {
		v.Public = *body.Public
	}
	if body.Status != nil {
		v.Status = *body.Status
	}
	if body.EnableVoting == nil {
		v.EnableVoting = false
	}
	if body.BusinessEmailRequired == nil {
		v.BusinessEmailRequired = false
	}
	if body.SsoGroupEnabled == nil {
		v.SsoGroupEnabled = false
	}
	if body.IsAuditEnabled == nil {
		v.IsAuditEnabled = false
	}
	if body.Public == nil {
		v.Public = false
	}
	if body.Status == nil {
		v.Status = "active"
	}
	if body.Writers != nil {
		v.Writers = make([]string, len(body.Writers))
		for i, val := range body.Writers {
			v.Writers[i] = val
		}
	}
	v.ID = &id
	v.Version = version
	v.BearerToken = bearerToken
	v.Etag = etag

	return v
}

// NewDeleteCommitteePayload builds a committee service delete-committee
// endpoint payload.
func NewDeleteCommitteePayload(id string, version *string, bearerToken *string, etag *string) *committee.DeleteCommitteePayload {
	v := &committee.DeleteCommitteePayload{}
	v.ID = &id
	v.Version = version
	v.BearerToken = bearerToken
	v.Etag = etag

	return v
}

// ValidateCreateCommitteeRequestBody runs the validations defined on
// Create-CommitteeRequestBody
func ValidateCreateCommitteeRequestBody(body *CreateCommitteeRequestBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.Category == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("category", "body"))
	}
	if body.Name != nil {
		if utf8.RuneCountInString(*body.Name) > 100 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.name", *body.Name, utf8.RuneCountInString(*body.Name), 100, false))
		}
	}
	if body.Category != nil {
		if !(*body.Category == "Legal Committee" || *body.Category == "Finance Committee" || *body.Category == "Special Interest Group" || *body.Category == "Board" || *body.Category == "Technical Oversight Committee/Technical Advisory Committee" || *body.Category == "Technical Steering Committee" || *body.Category == "Marketing Oversight Committee/Marketing Advisory Committee" || *body.Category == "Marketing Committee/Sub Committee" || *body.Category == "Code of Conduct" || *body.Category == "Product Security" || *body.Category == "Technical Mailing List" || *body.Category == "Marketing Mailing List" || *body.Category == "Working Group" || *body.Category == "Committers" || *body.Category == "Maintainers" || *body.Category == "Ambassador" || *body.Category == "Government Advisory Council" || *body.Category == "Expert Group" || *body.Category == "Other") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.category", *body.Category, []any{"Legal Committee", "Finance Committee", "Special Interest Group", "Board", "Technical Oversight Committee/Technical Advisory Committee", "Technical Steering Committee", "Marketing Oversight Committee/Marketing Advisory Committee", "Marketing Committee/Sub Committee", "Code of Conduct", "Product Security", "Technical Mailing List", "Marketing Mailing List", "Working Group", "Committers", "Maintainers", "Ambassador", "Government Advisory Council", "Expert Group", "Other"}))
		}
	}
	if body.Description != nil {
		if utf8.RuneCountInString(*body.Description) > 2000 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.description", *body.Description, utf8.RuneCountInString(*body.Description), 2000, false))
		}
	}
	if body.Website != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.website", *body.Website, goa.FormatURI))
	}
	if body.Website != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.website", *body.Website, "^(https?://)?[^\\s/$.?#].[^\\s]*$"))
	}
	if body.ParentCommitteeID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.parent_committee_id", *body.ParentCommitteeID, goa.FormatUUID))
	}
	if body.Status != nil {
		if !(*body.Status == "active" || *body.Status == "inactive" || *body.Status == "archived") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.status", *body.Status, []any{"active", "inactive", "archived"}))
		}
	}
	return
}

// ValidateUpdateCommitteeRequestBody runs the validations defined on
// Update-CommitteeRequestBody
func ValidateUpdateCommitteeRequestBody(body *UpdateCommitteeRequestBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.Category == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("category", "body"))
	}
	if body.Name != nil {
		if utf8.RuneCountInString(*body.Name) > 100 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.name", *body.Name, utf8.RuneCountInString(*body.Name), 100, false))
		}
	}
	if body.Category != nil {
		if !(*body.Category == "Legal Committee" || *body.Category == "Finance Committee" || *body.Category == "Special Interest Group" || *body.Category == "Board" || *body.Category == "Technical Oversight Committee/Technical Advisory Committee" || *body.Category == "Technical Steering Committee" || *body.Category == "Marketing Oversight Committee/Marketing Advisory Committee" || *body.Category == "Marketing Committee/Sub Committee" || *body.Category == "Code of Conduct" || *body.Category == "Product Security" || *body.Category == "Technical Mailing List" || *body.Category == "Marketing Mailing List" || *body.Category == "Working Group" || *body.Category == "Committers" || *body.Category == "Maintainers" || *body.Category == "Ambassador" || *body.Category == "Government Advisory Council" || *body.Category == "Expert Group" || *body.Category == "Other") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.category", *body.Category, []any{"Legal Committee", "Finance Committee", "Special Interest Group", "Board", "Technical Oversight Committee/Technical Advisory Committee", "Technical Steering Committee", "Marketing Oversight Committee/Marketing Advisory Committee", "Marketing Committee/Sub Committee", "Code of Conduct", "Product Security", "Technical Mailing List", "Marketing Mailing List", "Working Group", "Committers", "Maintainers", "Ambassador", "Government Advisory Council", "Expert Group", "Other"}))
		}
	}
	if body.Description != nil {
		if utf8.RuneCountInString(*body.Description) > 2000 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.description", *body.Description, utf8.RuneCountInString(*body.Description), 2000, false))
		}
	}
	if body.Website != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.website", *body.Website, goa.FormatURI))
	}
	if body.Website != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.website", *body.Website, "^(https?://)?[^\\s/$.?#].[^\\s]*$"))
	}
	if body.ParentCommitteeID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.parent_committee_id", *body.ParentCommitteeID, goa.FormatUUID))
	}
	if body.Status != nil {
		if !(*body.Status == "active" || *body.Status == "inactive" || *body.Status == "archived") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.status", *body.Status, []any{"active", "inactive", "archived"}))
		}
	}
	return
}
